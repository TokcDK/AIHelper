using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using AIHelper.Manage;
using static AIHelper.Manage.ManageModOrganizer;

namespace AIHelper.Data.Modlist
{
    internal class ModlistData
    {
        internal string ModlistPath = "";
        internal List<ModData> Mods;
        internal Dictionary<string, ModData> ModsByName;

        internal const string ListDescriptionMarker = "# This file was automatically generated by Mod Organizer.";
        internal const string SeparatorMarker = "_separator";

        /// <summary>
        /// init and load content of modlist for current profile
        /// </summary>
        public ModlistData()
        {
            Mods = new List<ModData>();
            ModsByName = new Dictionary<string, ModData>();
            Load();
        }

        /// <summary>
        /// init and load content of modlist for selected path
        /// </summary>
        public ModlistData(string modListPath)
        {
            Mods = new List<ModData>();
            ModsByName = new Dictionary<string, ModData>();
            Load(modListPath);
        }

        /// <summary>
        /// modlist load
        /// </summary>
        void Load(string modListPath = null)
        {
            ModlistPath = modListPath ?? ManageSettings.CurrentMoProfileModlistPath;

            if (!File.Exists(ModlistPath)) return;

            var modlistContent = File.ReadAllLines(ManageSettings.CurrentMoProfileModlistPath);
            Array.Reverse(modlistContent);

            var modPriority = 0;
            ModData lastSeparator = null;
            foreach (var line in modlistContent)
            {
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#", StringComparison.InvariantCulture))
                {
                    continue;
                }

                var mod = new ModData();
                mod.Priority = modPriority;
                mod.IsEnabled = line[0] == '+';
                var indexOfSeparatorMarker = line.IndexOf(SeparatorMarker, StringComparison.InvariantCulture);
                mod.IsSeparator = indexOfSeparatorMarker > -1;
                mod.Name = line.Substring(1);
                mod.Path = Path.Combine(ManageSettings.CurrentGameModsDirPath, mod.Name);
                mod.IsExist = Directory.Exists(mod.Path);
                mod.ParentSeparator = lastSeparator;


                if (!mod.IsSeparator && lastSeparator != null)
                {
                    lastSeparator.Childs.Add(mod); // add subitems references to understand which items is under the group separator
                }

                // reset separator if was changed
                if (mod.IsSeparator && lastSeparator != mod.ParentSeparator) lastSeparator = mod;

                Mods.Add(mod);
                ModsByName.Add(mod.Name, mod);

                modPriority++;
            }
        }

        internal void Insert(ModData profileModlistRecord, string modToPlaceWith = "", bool placeAfter = true)
        {
            ModData existsItem = GetItemByName(profileModlistRecord.Name);
            if (existsItem != null)
            {
                // activate or deactivate item if it already exists
                existsItem.IsEnabled = profileModlistRecord.IsEnabled;
                return;
            }

            // add by parent separator
            if (profileModlistRecord.ParentSeparator != null && profileModlistRecord.ParentSeparator.Name.Length > 0)
            {
                bool added = false;
                var modPriority = 0;

                bool groupFound = false;
                var newItems = new List<ModData>();
                ModData foundGroup = null;
                foreach (var item in Mods)
                {
                    if (!added && !groupFound && item.IsSeparator && item.Name == profileModlistRecord.ParentSeparator.Name)
                    {
                        foundGroup = item;
                        groupFound = true;
                    }
                    else if (!added && groupFound && item.IsSeparator && item.Name != profileModlistRecord.ParentSeparator.Name)
                    {
                        // set parent group, new priority and increase priority number
                        foundGroup.Childs.Add(profileModlistRecord); // add inserting item in list of under separator
                        profileModlistRecord.ParentSeparator = foundGroup;
                        profileModlistRecord.Priority = modPriority++;

                        newItems.Add(profileModlistRecord);
                        added = true;
                    }

                    item.Priority = modPriority;
                    newItems.Add(item);

                    modPriority++;
                }

                if (!added) // add in the end when was not added
                {
                    profileModlistRecord.Priority = modPriority;
                    profileModlistRecord.ParentSeparator = null;
                    newItems.Add(profileModlistRecord);
                }

                Mods = newItems;

                return;
            }

            //add by modToPlaceWith
            if (!string.IsNullOrWhiteSpace(modToPlaceWith))
            {
                bool added = false;
                var modPriority = 0;
                bool placeMeNow = false;

                var newItems = new List<ModData>();
                foreach (var item in Mods)
                {
                    if (!added && placeMeNow)
                    {
                        profileModlistRecord.Priority = modPriority++;
                        newItems.Add(profileModlistRecord);
                        added = true;
                    }
                    else if (!added && !placeMeNow && item.Name == profileModlistRecord.Name)
                    {
                        if (placeAfter)
                        {
                            placeMeNow = true;
                        }
                        else
                        {
                            profileModlistRecord.Priority = modPriority++;
                            newItems.Add(profileModlistRecord);
                            added = true;
                        }
                    }

                    item.Priority = modPriority++;
                    newItems.Add(item);
                }

                if (!added) // add in the end when was not added
                {
                    profileModlistRecord.Priority = modPriority;
                    profileModlistRecord.ParentSeparator = null;
                    newItems.Add(profileModlistRecord);
                }

                Mods = newItems;

                return;
            }


            // add by priority
            // insert at the end if mod priority is not set or more of max
            if (profileModlistRecord.Priority == -1 || profileModlistRecord.Priority >= Mods.Count)
            {
                profileModlistRecord.Priority = Mods[Mods.Count - 1].Priority + 1; // correct priority
                Mods.Add(profileModlistRecord);
                return;
            }
            Mods.Insert(profileModlistRecord.Priority - (profileModlistRecord.Priority > 0 ? 1 : 0), profileModlistRecord);
        }

        private ModData GetItemByName(string itemName)
        {
            if (ModsByName.ContainsKey(itemName)) return ModsByName[itemName];

            return null;
        }

        /// <summary>
        /// get list of mods from all items by selected mod type
        /// </summary>
        /// <param name="modType">Enabled, Disabled, Separator</param>
        /// <returns>list of mods by mod type</returns>
        internal List<ModData> GetListBy(ModType modType) { return GetBy(modType).ToList(); }

        /// <summary>
        /// get mods from all items by selected mod type
        /// </summary>
        /// <param name="modType">Enabled, Disabled, Separators</param>
        /// <param name="exists">True by default. Determines if add only existing mod folders</param>
        /// <returns>list of mods by mod type</returns>
        internal IEnumerable<ModData> GetBy(ModType modType, bool exists = true)
        {
            foreach (var mod in Mods)
            {
                switch (modType)
                {
                    case ModType.Separator when mod.IsSeparator:
                    case ModType.ModAny when !mod.IsSeparator:
                    case ModType.ModEnabled when !mod.IsSeparator && mod.IsEnabled:
                    case ModType.ModDisabled when !mod.IsSeparator && !mod.IsEnabled:
                        if (!exists || mod.IsExist) // mod exists or exists is false
                            yield return mod;
                        break;
                }
            }
        }

        /// <summary>
        /// mod type
        /// </summary>
        internal enum ModType
        {
            /// <summary>
            /// any enabled or disabled mods
            /// </summary>
            ModAny,
            /// <summary>
            /// only enabled mods
            /// </summary>
            ModEnabled,
            /// <summary>
            /// only disabled mods
            /// </summary>
            ModDisabled,
            /// <summary>
            /// only separators
            /// </summary>
            Separator
        }

        /// <summary>
        /// save modlist
        /// </summary>
        internal void Save()
        {
            if (!File.Exists(ModlistPath)) return;

            var writeItems = new List<ModData>(Mods);
            writeItems.Reverse();
            using (var newModlist = new StreamWriter(ModlistPath))
            {
                newModlist.WriteLine(ListDescriptionMarker);
                foreach (var item in writeItems) newModlist.WriteLine((item.IsEnabled ? "+" : "-") + item.Name);
            }
        }
    }
    internal class ModData
    {
        /// <summary>
        /// priority in modlist
        /// </summary>
        internal int Priority = -1;
        /// <summary>
        /// name of mod dir or name of separator dir
        /// </summary>
        internal string Name;
        /// <summary>
        /// path to folder
        /// </summary>
        internal string Path;
        /// <summary>
        /// true when enabled. separators is always disabled
        /// </summary>
        internal bool IsEnabled;
        /// <summary>
        /// true when folder is exists in mods
        /// </summary>
        internal bool IsExist;
        /// <summary>
        /// true for separators
        /// </summary>
        internal bool IsSeparator = false;
        /// <summary>
        /// parent separator
        /// </summary>
        internal ModData ParentSeparator;
        /// <summary>
        /// child items for separator
        /// </summary>
        internal List<ModData> Childs = new List<ModData>();
        /// <summary>
        /// Mod relations with other mods
        /// </summary>
        internal ModRelationsData Relations = new ModRelationsData();
        /// <summary>
        /// Mod messages
        /// </summary>
        internal List<string> ReportMessages = new List<string>();
    }

    internal class ModRelationsData
    {
        internal List<ModData> Requires = new List<ModData>();
        internal List<ModData> RequiresOr = new List<ModData>();
        internal List<ModData> IncompatibleWith = new List<ModData>();
        internal List<ModData> IncompatibleWithOr = new List<ModData>();
    }

    internal class ModListReportMessage
    {
        internal string Message { get; }

        public ModListReportMessage(string message)
        {
            Message = message;
        }
    }
}
